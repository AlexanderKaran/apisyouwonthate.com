# Status Codes, Errors and Messages {#chapter-4}

## Introduction

If everything goes smoothly you want to show some data. If a valid request comes in for a data which is valid you show data, if creating something on the API with valid data, you show the created object. If something goes wrong, however, you want to let people know what is wrong using two simultaneous approaches: 

1. HTTP status codes
2. Custom error codes and messages

## HTTP Status Codes

Status Codes are used in all responses and have a number from 200 to 507 - with plenty of gaps in between - and each has a message and a definition. Most server-side languages, frameworks, etc default to "200 OK". 

Status codes are grouped into a few different categories:

**2xx is all about success**  
Whatever the client tried to do was successful up to the point that the response was send. Keep in mind that a status like 202 Accepted doesn’t say anything about the actual result, it only indicates that a request was accepted and is being processed asynchronously.

**3xx is all about redirection**  
These are all about sending the calling application somewhere else for the actual resource. The best known of these are the 303 See Other and the 301 Moved Permanently which are used a lot on the web to redirect a browser to another URL.

**4xx is all about client errors**  
With these status codes we indicate that the client has done something invalid and needs to fix the request before resending it.

**5xx is all about service errors**  
With these status codes we indicate that something went wrong in the service. For example a database connection failed. Typically a client application can retry the request. The server can even specify when the client is allowed to retry the command using a Retry-After HTTP header.

*[Using HTTP status codes in a REST service](http://www.develop.com/httpstatuscodesrest) -- Maurice de Beijer*

For a more complete list of HTTP status codes and their definitions the [REST & WOA Wiki](http://restpatterns.org/HTTP_Status_Codes) has an extensive list of them.

Arguments between developers will continue for the rest of time over the exact appropriate code to use in any given situation, but these are the status codes the API uses at Kapture:

* 200 - Generic everything is OK
* 201 - Created something OK
* 202 - Accepted but is being processed async (for a video means encoding, for an image means resizing, etc)
* 400 - Bad Request (should really be for invalid syntax, but some folks use for validation)
* 401 - Unauthorized (no current user and there should be)
* 403 - The current user is forbidden from accessing this data
* 404 - That URL is not a valid route, or the item resource does not exist
* 410 - Data has been deleted, deactivated, suspended, etc
* 405 - Method Not Allowed (your framework will probably do this for you)
* 500 - Something unexpected happened and it is the APIs fault
* 503 - API is not here right now, please try again later

It can be tempting to try and squeeze as many error codes in as you can, but I would advise you to try and keep it simple. You won't unlock any achievements for using them all.

Most 5xx issues will most likely happen under odd architecture or server related issues that are nothing to do with your API, like if PHP-FPM segfaults behind nginx (502), if your Amazon Elastic Load Balancer has no healthy instances (503) or if your hard-drive fills up somehow (507).

## Error Codes and Error Messages

Error codes are usually strings or integers that act as a unique index to a correspond human-readable error message with more information about what is going wrong. That sounds a lot like HTTP status codes, but these errors are about application specific things that may or may not be anything to do with HTTP specific responses.

Some folks will try to use HTTP status codes exclusively and skip using error codes because they do not like the idea of making their own error codes or having to document them, but this is not a scalable approach. There will be some situations where the same endpoint could easily return the same status code for more than one different condition. The status codes are there to merely hint what is going on, relying on the actual error code and error message to provide more information if the client is interested.

For example, an issue with the access token will always result in the user not being recognized. An uninterested client would simply say "User could not get in" while a more interested client would probably prefer to offer suggestions via messages in their own webapp/iPhone app interface. 

~~~~~~~~
{ 
  "error": {
    "type": "OAuthException",
    "message": "Session has expired at unix time 1385243766.
The current unix time is 1385848532."
  }
}
~~~~~~~~

Everyone can understand that. 

Facebook sadly is missing an error code, so sometimes you find yourself doing string checking on the message which is lunacy. 

Foursquare is not a bad example of using both, but they place an emphasis on tying their errors to a status code.
 
<https://developer.foursquare.com/overview/responses>

 Twitter does a great job of having HTTP status codes documented and having specific error codes for other issues too. Some are tied to HTTP status codes (which is fine) but many are not. Some are also tied to the same status code, highlighting the issues raised above.
 
 <https://dev.twitter.com/docs/error-codes-responses>
 
|Code | Text                                              | Description                                                |
|-----|---------------------------------------------------|------------------------------------------------------------|
|161  | You are unable to follow more people at this time | Corresponds with HTTP 403 - thrown when a user cannot follow another user due to some kind of limit |
|179  | Sorry, you are not authorized to see this status  | Corresponds with HTTP 403 - thrown when a Tweet cannot be viewed by the authenticating user, usually due to the tweet's author having protected their tweets. |

### Programmatically Detecting Error Codes

You can use error codes to make an application respond intelligently to failure of something as basic as a posted Twitter 
status.

{title="Using Python to catch exceptions and react to the Twitter error code", lang=python}
~~~~~~~~
try:
    api.PostUpdates(body['text'])

except twitter.TwitterError, exc:

    skip_codes = [
        # Page does not exist
        34,

        # You cannot send messages to users who are not following you
        150,

        # Sent too many
        # TODO Make this requeue with a dekay somehow
        151
    ]

    error_code = exc.__getitem__(0)[0]['code']

    # If the error code is one of those listed before, let’s just end here
    if error_code in skip_codes:
        message.reject()

    else:
        # Rate limit exceeded? Might be worth taking a nap before we requeue
        if error_code == 88:
            time.sleep(10)

        message.requeue()
~~~~~~~~
                
Compare this sort of logic with Facebook - and their lack of error codes:
    
{title="Using Python to analyse Facebook error strings as no codes exist", lang=python}
~~~~~~~~
except facebook.GraphAPIError, e:

    phrases = ['expired', 'session has been invalidated']

    for phrase in phrases:

        # If the token has expired then lets knock it out so we dont try again
        if e.message.find(phrase) > 0:
            log.info("Deactivating Token %s", user['token_id'])
            self._deactivate_token(user['token_id'])

    log.error("-- Unknown Facebook Error", exec_info=True)
~~~~~~~~

If they change their error messages then this might stop working, which would be a problem. Codes (that
do not change) are a much more sensible way to go about this.

{title="If Facebook added codes and documentation links to GraphAPI error responses.", lang=json}
~~~~~~~~
{ 
  "error": {
    "type": "OAuthException",
    "code": "ERR-01234",
    "message": "Session has expired at unix time 1385243766. The current unix time is 1385848532."
    "href": "http://example.com/docs/errors/#ERR-01234"
  }
}
~~~~~~~~

## Error or Errors

When returning errors, I always used to return just one error. In the case of validation I would return 
them one at a time, as an easy way to exit out of a controller. Thinking about it this was probably just
laziness, but after being forced to work with the JSON-API standard the use of multiple errors
started to feel more natural. 

{title="If Facebook returned multiple errors in a list for GraphAPI responses.", lang=json}
~~~~~~~~
{ 
  "errors": [{
    "type": "OAuthException",
    "code": "ERR-01234",
    "message": "Session has expired at unix time 1385243766. The current unix time is 1385848532."
    "href": "http://example.com/docs/errors/#ERR-01234"
  }]
}
~~~~~~~~

## Standards for Error Responses

So far this chapter has used entirely home-grown formats for errors. It is incredibly common even with
the most popular APIs to build completely arbitrary error formats, so I wanted to teach you the theory
before forcing you to read complicated standards. 

There are two popular standards which cover error reporting, which are both fairly similar, but sadly 
still in Draft at time of writing.

### JSON-API

[JSON-API](http://jsonapi.org/format/#errors) is discussed in a few sections of this book, and is a 
standard outlining the general format of requests and responses in JSON when working with HTTP APIs. It
has a section on errors, which I quite like. 

The following is an excerpt from the JSON-API standard at time of writing. 

> An error object MAY have the following members:

>  * `"id"` - A unique identifier for this particular occurrence of the problem.
>  * `"href"` - A URI that MAY yield further details about this particular occurrence of the problem.
>  * `"status"` - The HTTP status code applicable to this problem, expressed as a string value.
>  * `"code"` - An application-specific error code, expressed as a string value.
>  * `"title"` - A short, human-readable summary of the problem. It SHOULD NOT change from occurrence to > occurrence of the problem, except for purposes of localization.
>  * `"detail"` - A human-readable explanation specific to this occurrence of the problem.
>  * `"links"` - Associated resources which can be dereferenced from the request document.
>  * `"path"` - The relative path to the relevant attribute within the associated resource(s). Only appropriate for problems that apply to a single resource or type of resource.

> Additional members MAY be specified within error objects.

When you make your API responses, you pretty much just need to make an array with items that looks a bit
like this.

~~~~~~~~
{
  "errors": [{
    "code": "ERR-01234",
    "title": "OAuth Exception",
    "details": "Session has expired at unix time 1385243766. The current unix time is 1385848532.",
    "href": "http://example.com/docs/errors/#ERR-01234"
  }]
}
~~~~~~~~

See how that Facebook example has been slightly tweaked to follow the standard? Nice and easy.

### Problem Details for HTTP APIs

This is currently a [draft RFC](http://tools.ietf.org/html/draft-nottingham-http-problem), which at the
time of writing was on Draft 7. 

The goal of this RFC is to define a "problem detail" like we have been doing throughout this chapter, 
but in a standard way - to avoid inventing new formats for each and every HTTP API. It is being headed up
by Mark Nottingham, which is a name that will come up a few times in this book.

Mark wrote a [tutorial about Problem Details] which will explain the standard a little better. 

If you are interested in implementing this standard then there are tools to make it easy:

* [crell/api-problems] for PHP

[tutorial about Problem Details]: https://www.mnot.net/blog/2013/05/15/http_problem
[crell/api-problems]: https://github.com/Crell/ApiProblem


## Common Pitfalls

### 200 OK and Error Code

If you return a HTTP status code of 200 with an error code then Chuck Norris will roundhouse your door in, destroy your computer, instantly 35-pass wipe your backups, cancel your Dropbox account and block you from GitHub. HTTP 4xx or 5xx codes alert the client that something bad happened, and error codes provide specifics of the exact issue if the client is interested.

### Non-Existent, Gone, or Hiding?

404 is drastically overused in applications. People use it for "never existed", "no longer exists", "you can't view it" and "it is deactivated" which is way too vague. That can be split up into 404, 403 and 410 but this is still vague.

If you get a 403 this could be because the requesting user is in not in the correct group to see the requested content. Should the client suggest you upgrade your account somehow? Are you not friends with the users content you are trying to view? Should the client suggest you add them as a friend?

A 410 on a resource could be due to a user deleting that entire piece of content or it could be down to the user deleting their entire account.

In all of these situations the ideal solution is to complement the HTTP status code with an error code, which can be whatever you want as long as they are unique within your API and documented somewhere. Do not do what Google does and supply a list of error codes then have other error codes which are not documented anywhere, because if I see that I will come for you.
