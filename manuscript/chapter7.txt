# Data Relationships {#chapter-7}

## Introduction

If you have ever worked with relational databases the chances are you understand relationships. Users have
comments. Authors have one or many books. Books belong to a Publisher. Southerners have one or more teeth.
 Whatever the example, relationships are incredibly important to any application and therefore an API too.

Relationships for your API output do not need to be directly mapped to database relationships.
If your database relationships are built properly, relationships will often be similar, but your
output might have extra dynamic relationships that are not defined by a JOIN, and might not
necessarily include every possible database relationship.

Put more eloquently:

> REST components communicate by transferring a representation of a resource in a format matching one of
an evolving set of standard data types, selected dynamically based on the capabilities or desires of
the recipient and the nature of the resource. Whether the representation is in the same format as the raw
source, or is derived from the source, remains hidden behind the interface.
> -- [Roy Fielding](http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm#sec_5_2)

This explanation highlights an important factor: the output has to be based on the "desires of
the recipient". There are many popular approaches to designing relationships, but many of them do
not satisfy the "desires of the recipient". Still, I will cover the popular approaches
with their pros and cons regardless.

## Sub-Resources

One very simplistic way to approach related data is to offer up new URLs for your API consumers
to digest. This was covered lightly in [Chapter 2: Planning and Creating Endpoints](#chapter-2), and is
a perfectly valid approach.

If an API has `places` as a resource and wants to allow access to a places checkins, an
endpoint could be made to handle exactly that:

> /places/X/checkins

The downside here is that if you have already requested `GET /places/X` then fetching the checkins
will require an extra HTTP request. Imagine a mobile app that wants to get
all `places` in an area and put them on a map, then allow a user to browse through them. If the `place`
search happens as one request, then the `/places/X/checkins` is executed each time the user clicks on a
place, forcing the user to do a lot of unecessary waiting. This is known as `1 + n`, meaning the work
done is increased by an extra one request for each `place` you look up.

That also assumes the only related data is checkins. At Kapture our API also has `merchant`, `images`,
`current_campaign` and `previous_campaigns` to look up. Using "sub-resources" only would mean that four
extra HTTP requests per place need to happen, which is `1 + 4n`.

If 50 `places` were returned and each time the related data had to be loaded, assuming the app user looked
through all 50 `places` there would be 1 initial request to get 50 results. For each of those results
would be 4 more, meaning: `1 + (50 x 4) = 251`. 251 HTTP requests happening (even assuming they are
asyncronous) is just unnecessary and going over HTTP on a mobile is the slowest things you can do. Even with
caching, depending on the data set, it could still be 251 requests.

Some API developers try to avoid going over HTTP too many times by shoving as much data as possible into one request, so when you call the `/places` endpoint you automatically get `checkins`, `current_opps`,
`merchants` and `images`. Well, if you do not want that information you are waiting for huge file
downloads full of irrelevant JSON! Even with GZIP compression enabled on the web-server, downloading
something you do not need is obviously not desirable, and can be avoided. This can mean major performance
gains on mobile, and minor gains over a slow network or weak Wi-Fi for desktop or tablets.

The trade-off here between "downloading enough data to avoid making the user wait for subsequent loads"
and "downloading too much data to make them wait for the initial load" is hard. An API needs the
flexibility and making sub-resources the only way to load related data is restrictive for the API consumer.

## Foreign Key Arrays

Another approach to related data is to provide an array of foreign keys in the output. To use
the [JSON-API](http://jsonapi.org/) standard as an example, if a `post` has multiple
`comments`, the `/posts` endpoint might contain the following:

~~~~~~~~
{
  "post": {
    "id": 1
    "title": "Progressive Enhancement is Dead",
    "_links": {
      "comments": ["1", "3"]
    }
  }
}
~~~~~~~~

Here you still end up with `n + 1` requests, but at least you can take those IDs and make a grouped
request like `/comments/1,2` or `/comments?ids=1,2` to reduce how many HTTP requests are being made.

Back to the places example, if you have 50 places returned and need 4 extra pieces of data, you could
iterate through the 50, map which items expect which pieces of data, request all unique pieces of data
and only end up with `1 + 4 = 5` HTTP requests instead of 251.

The downside is that the API consumer has to stitch all of that data together, which could be a lot of
work for a large dataset.

## Compound Documents (a.k.a Side-Loading)

Instead of just putting the foreign keys into the resource you can take things a step further and
side-load the data, which is also recommended by JSON-API.

> Compound documents contain multiple collections to allow for side-loading of related objects.
Side-loading is desirable when nested representation of related objects would result in potentially
expensive repetition. For example, given a list of 50 comments by only 3 authors, a nested representation
would include 50 author objects where a side-loaded representation would contain only 3 author objects.
> -- **Source:** [canvas.instructure.com](https://canvas.instructure.com/doc/api/file.compound_documents.html)

If we look at a collection of posts following the example from "Foreign Key Arrays," an API might
show a response like this:

~~~~~~~~
{
  "posts": [{
    "id": "1"
    "title": "Awesome API Book",
    "_links": {
      "comments": ["1", "2"]
    }, {
    "id": "2"
    "title": "But Really That API Book",
    "_links": {
      "comments": ["3"]
    }
  }],
  "_linked": {
    "comments": [
      {
        "id": "1"
        "message": "Great book",
        "created_at": "2014-08-23T18:20:03Z"
      },
      {
        "id": "2"
        "message": "I lolled",
        "created_at": "2014-08-24T20:04:01Z"
      },
      {
        "id": "3"
        "message": "Ugh JSON-API...",
        "created_at": "2014-08-29T14:01:13Z"
      }
    ]
  }
}
~~~~~~~~

Just like with the "Foreign Key Array" approach, the client will have to do a lot of sticking
together to map which comment belongs to which post. The data is all there, but getting it into
a format for easy iteration could be a PITA.

That said, it will avoid duplicating the same item multiple times. While a `comment` would likely
only be on a single post, if you were to include `user` information, the same user could show up
multiple times as a commenter if they are active, or even as a commenter _and_ a post author.

## Embedded Documents (a.k.a Nesting)

Instead of flattening the entire response to top level collections and losing the obvious context
of the data, embedding data leaves it in the structure a client would expect.

This approach was used for the last two versions of the API at Kapture, used it on a few other APIs. It offers the most flexibility for the API consumer; it can reduce HTTP requests or reduce
download size depending on what the consumer wants.

An API consumer could call the endpoint with the following query string parameter:

~~~~~~~~
/places?include=checkins,merchant
~~~~~~~~

This would alert Fractal (if properly configured) to include the `checkins` for that `place`, and the `merchant` data in the response inside the `place` resource:

~~~~~~~~
{
    "data": [
        {
            "id": 2,
            "name": "Videology",
            "lat": 40.713857,
            "lon": -73.961936,
            "created_at": "2013-04-02",
            "checkins" : [
                // ...
            ],
            "merchant" : {
                // ...
            }
        },
        {
            "id": 1,
            "name": "Barcade",
            "lat": 40.712017,
            "lon": -73.950995,
            "created_at": "2012-09-23",
            "checkins" : [
                // ...
            ],
            "merchant" : {
                // ...
            }
        }
    ]
}
~~~~~~~~

Some systems (like Facebook, or any API using Fractal) will let you nest those embeds with dot notation:

**E.g:** `/places?include=checkins,merchant,current_opp.images`

### Embedding with Fractal

Picking back up from Chapter 6, your transformer at this point is mainly just giving you a method to
handle array conversion from your data source to a simple array. Fractal can however include resources
and collections too. Continuing the theme of users, places and checkins, the `UserTransformer` might
have a checkins list, to see a users checkin history.

<<[UserTransformer using Fractal](../src/chapter7/app/src/App/Transformer/UserTransformer.php)

The `CheckinTransfer` can then have both a `user` and a `place`. There is no benefit to requesting the user in this
context, because we know that already, but asking for the place would return information about the location that is
being checked into.

<<[CheckinTransformer using Fractal](../src/chapter7/app/src/App/Transformer/CheckinTransformer.php)

These examples happen to be using the lazy-loading functionality of an ORM for `$user->checkins` and `$checkin->place`, but
there is no reason that eager-loading could not also be used by inspecting the `$_GET['include']` list
of requested scopes. Something like this can easily go in your controller constructor, somewhere in the
base controller or... something:

{title="Example of user input dictating which Eloquent ORM (Laravel) relationships to eager-load", lang=php}
~~~~~~~~~
$requestedEmbeds = Input::get('include'); // ['checkins', 'place'] or just ['place']

// Left is relationship names. Right is include names.
// Avoids exposing relationships and whatever not directly set
$possibleRelationships = [
    'checkins' => 'checkins',
    'venue' => 'place',
];

// Check for potential ORM relationships, and convert from generic "include" names
$eagerLoad = array_keys(array_intersect($possibleRelationships, $requestedEmbeds));

$books = Book::with($eagerLoad)->get();

// do the usual fractal stuff
~~~~~~~~~

Having the following code somewhere in the `ApiController`, or in your bootstrap, will make this all work:

~~~~~~~~~
class ApiController
{
    // ...

    public function __construct(Manager $fractal)
    {
        $this->fractal = $fractal;

        // Are we going to try and include data?
        if (Input::get('include')) {
          $this->fractal->parseIncludes(Input::get('include'));
        }
    }

    // ...
}
~~~~~~~~~

That is how you would do things in Laravel at least.

### Embedding with Rails

The Rails lot are big fans of their ActiveRecord package, and most suggest to use it to embed data. The
specific part is in the [Serializaton::to_json Documentation](http://apidock.com/rails/ActiveRecord/Serialization/to_json).

To include associations, use `blog.to_json(:include => :posts)`.

~~~~~~~~~
{
  "id": 1, "name": "Konata Izumi", "age": 16,
  "created_at": "2006/08/01", "awesome": true,
  "posts": [{
    "id": 1,
    "author_id": 1,
    "title": "Welcome to the weblog"
  }, {
    "id": 2,
    author_id: 1,
    "title": "So I was thinking"
  }]
}
~~~~~~~~~

2nd level and higher order associations work as well.

~~~~~~~~~
blog.to_json(:include => {
  :posts => {
    :include => {
      :comments => {
        :only => :body
      }
    },
    :only => :title
  }
})
~~~~~~~~~

A little more complicated, but you get more control over what is returned.

~~~~~~~~~
{
  "id": 1,
  "name": "Konata Izumi",
  "age": 16,
  "created_at": "2006/08/01",
  "awesome": true,
  "posts": [{
    "comments": [{
      "body": "1st post!"
    }, {
      "body": "Second!"
    }],
    "title": "Welcome to the weblog"
  },
  {
    "comments": [{
      "body": "Don't think too hard"
    }],
    "title": "So I was thinking"
  }]
}
~~~~~~~~~

This will work well assuming everything is represented as ActiveRecord, which who knows, it might be.

## Summary

The most important thing here is that an API has _some_ way to include related data. Regardless of whether
side-loading or embedding is the approach used, it is important to pick one.

One area that may effect your decision is using a JavaScript framework like EmberJS. In theory an
API should not concern itself with implementation specific details like which JavaScript framework
is being used, but if that EmberJS platform is a requirement of the business then picking a
compatible data structure might be key.

EmberJS - at the time of writing - requires a somewhat specific side-loading approach, which might cause a headache for other consumers of your API.

Fractal will make your decision less important as using [Serializers] you can switch between the
two types rather easily. Later on the book will talk about looking at MIME types and responding
with different data, so it would not be difficult to use different headers for different data
structures, one custom output maybe using the embedded approach, and one JSON-API with side-loaded
data, for example.

[Serializers]: http://fractal.thephpleague.com/serializers/
